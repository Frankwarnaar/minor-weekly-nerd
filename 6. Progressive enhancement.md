# Building a progressive enhanced realtime poll

Progressive enhancement (PE) is a methodology where you build web apps with the purpose of making it work everywhere from the beginning and adding layers of enhancement after that, to make it work better. In my experience, PE makes the result in the end better, and might even save you some time in development.

For the user PE enhancement is a good thing. Everything works everywhere, no matter what browser you're using or how bad your internet connection is. When your browser supports more features, your experience will improve.

## Layers
PE ussualy contains 3 layers, built in the next order: 
1. Baseline: Start building a baseline that works everywhere. Typically this means using just semantic HTML and doing all the logic server side. Try to restrict yourself to just using forms and links to make your most viable product work.
2. Acceptable: Once you've built the baseline, enhance this layer to make it acceptable for the user. Usually this means enhancing it with CSS. Make it look better. Make sure you don’t actually make things less usable with CSS, for instance by hiding labels of inputs.
3. Enjoyable: Enhance your product to make it work pleasurable. Usually this is where javascript comes in.

## Building a realtime poll

NOTE: In this example i’m just showing the results view. If you want an example of how I’ve built everything else, have a look at my repository [realtime poll](https://github.com/Frankwarnaar/minor-browser-technologies-realtime-poll).

### 1.Baseline
The baseline contains of just semantic HTML:
```html
<html lang="en"><head>
	<meta charset="UTF-8">
	<title>Poll</title>
	<meta name="viewport" content="width=device-width">
	<link href="/css/app.css" rel="stylesheet">
	<meta http-equiv="refresh" content="10">
</head>
<body>
	<section data-poll-id="f0c706c0-157d-11e7-8e5a-397dac5d545f">
		<h1>How old is Jelmer</h1>
		<ul class="results">
			<li data-answer="17">
				<h2 data-answer="17">17</h2>
				<meter data-meter data-answer="17" max="6" value="2">
					<div class="meter__fill" data-answer="17" style="width: 33.33333333333333%"></div>
				</meter>
				<p data-votes data-answer="17">2 votes
					<span>(100%)</span>
				</p>
			</li>
			<li data-answer="18">
				<h2 data-answer="18">18</h2>
				<meter data-meter data-answer="18" max="6" value="0">
					<div class="meter__fill" data-answer="18" style="width: 0%"></div>
				</meter>
				<p data-votes data-answer="18">0 votes
					<span>(0%)</span>
				</p>
			</li>
		</ul>
</body>
</html>
```
Notice the `<meta http-equiv="refresh" content="10">` meta tag in the head. This makes the page refresh every 10 seconds, so this view keeps up to date. The data-attributes are used by the third layer of enhancement. Ignore them for now.
![baseline](https://raw.githubusercontent.com/Frankwarnaar/minor-weekly-nerd/master/6.progressive_enhancement/baseline.png?token=ANgg99g5ChVA03HuxhZJBo-eY7LVW6Ieks5ZO70awA%3D%3D)

### 2. Acceptable
With CSS I made it look some better.
![acceptable](https://github.com/Frankwarnaar/minor-weekly-nerd/blob/master/6.progressive_enhancement/acceptable.png?raw=true)

### 3. Enjoyable
With websockets, I made the results page update when someone voted on a poll. 
Server side code:
```js
const express = require('express');
const path = require('path');
const bodyParser = require('body-parser');
const http = require('http');
const WebSocketServer = require('ws').Server;

const app = express();
const server = http.createServer(app);
const wss = new WebSocketServer({server: server});

const polls = []; // Array in which all active polls are stored
let sockets = []; // Array in which all active sockets are stored

// Route to which users post their votes
app.post('/vote', (req, res) => {
	const poll = polls.find(poll => poll.id === req.body.id);
	poll.answers.map(answer => {
		if (answer.name === req.body.answer) {
			answer.votes++;
			poll.votes++;
		}
	});
	updatePoll(poll);
	sockets.map(socket => {
		socket.send(JSON.stringify(poll));
	});
	res.redirect(`/polls/results/${poll.id}`);
});

function updatePoll(poll) {
	polls.map(single => single.id === poll.id ? poll : single);
}

wss.on('connection', socket => {
	console.log('Client connected');
	sockets.push(socket);

	socket.on('close', () => {
		console.log('Client disconnected');
		sockets = sockets.filter(single => {
			return single !== socket;
		});
	});
});
```
With this code, the polls get sent to every user, when a new vote comes in.

NOTE: This code gets transpiled with babel to es2015 for browser support in old browsers!

Client side the socket messages get handled this way:
```html
<script>
try {
	const socket = new WebSocket(`ws://${window.location.hostname}:8000`, 'echo-protocol');
	// Remove refresh meta tag in head
	document.getElementsByTagName('head')[0].removeChild(document.querySelector('meta[content="10"]'))

	socket.onmessage = (e) => {
		renderResults(JSON.parse(e.data));
	};
	
}

function renderResults(poll) {
	const $poll = document.querySelector('[data-poll-id]');
	const $meters = document.querySelectorAll('[data-meter]');
	const $meterFills = [].slice.call(document.getElementsByClassName('meter__fill')); // Convert nodelist to array
	const $totalVotes = document.querySelectorAll('[data-poll-votes]');
	const $votes = this.app.utils.getElementsByAttribute('[data-votes]');

	if ($poll) {
		$totalVotes[0].innerHTML = poll.votes;

		const pollId = $poll.getAttribute('data-poll-id');
		if (pollId === poll.id) {
			poll.answers.forEach(answer => {
				$meters.forEach($meter => {
					if ($meter.getAttribute('data-answer') === answer.name) {
						$meter.setAttribute('value', answer.votes);
						$meter.setAttribute('max', poll.votes);
					}
				});

				$meterFills.forEach($fill => {
					$fill.style.width = `${answer.votes / poll.votes * 100}%`;
				});

				$votes.forEach($vote => {
					if ($vote.getAttribute('data-answer') === answer.name) {
						$vote.innerHTML = `${answer.votes} stemmen <span>(${(answer.votes / poll.votes * 100).toFixed()}%)</span>`;
					}
				});
			});
		}
	}
</script>
```

This way, the poll updates when new answers come in at the server. 

## Sources
1. [Sam Dwyer - Progressive Enhancement: What It Is, And How To Use It?](https://www.smashingmagazine.com/2009/04/progressive-enhancement-what-it-is-and-how-to-use-it/)
